package com.BE.QuitCare.service;

import com.BE.QuitCare.dto.*;
import com.BE.QuitCare.entity.Account;
import com.BE.QuitCare.entity.Appointment;
import com.BE.QuitCare.entity.Session;
import com.BE.QuitCare.entity.SessionUser;
import com.BE.QuitCare.enums.AppointmentEnum;
import com.BE.QuitCare.enums.LeaveStatus;
import com.BE.QuitCare.enums.Role;
import com.BE.QuitCare.exception.BadRequestException;
import com.BE.QuitCare.repository.AppointmentRepository;
import com.BE.QuitCare.repository.AuthenticationRepository;
import com.BE.QuitCare.repository.SessionRepository;
import com.BE.QuitCare.repository.SessionUserRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class SessionService
{

    @Autowired
    SessionRepository sessionRepository;
    @Autowired
    SessionUserRepository sessionUserRepository;
    @Autowired
    AuthenticationRepository authenticationRepository;
    @Autowired
    AuthenticationService  authenticationService;

    public List<Session> getTemplates() {
        return sessionRepository.findAll();
    }



    @PostConstruct
    public void initTemplates() {
        if (sessionRepository.count() == 0) {
            List<Session> templates = new ArrayList<>();
            LocalTime start = LocalTime.of(7, 0);
            LocalTime end = LocalTime.of(17, 0);

            while (start.plusMinutes(60).compareTo(end) <= 0) {
                Session template = new Session();
                template.setLabel(start.toString());
                template.setStart(start);
                template.setEnd(start.plusMinutes(60));
                templates.add(template);

                start = start.plusMinutes(60);
            }

            sessionRepository.saveAll(templates);
        }
    }

    @Transactional
    public void updateAvailabilityDay(RemoveSessionDTO dto) {
        Account account = authenticationRepository.findById(dto.getAccountId())
                .orElseThrow(() -> new BadRequestException("Không tìm thấy tài khoản"));

        if (account.getRole() != Role.COACH) {
            throw new BadRequestException("Chỉ Coach mới được xin nghỉ.");
        }

        if (dto.getDate().isBefore(LocalDate.now())) {
            throw new BadRequestException("Chỉ có thể xin nghỉ cho những ngày trong tương lai.");
        }

        List<SessionUser> sessions = sessionUserRepository.findByAccountAndDate(account, dto.getDate());

        if (sessions.isEmpty()) {
            throw new BadRequestException("Không có lịch làm nào trong ngày này để cập nhật.");
        }

        // Kiểm tra nếu có lịch hẹn đã được đặt
        for (SessionUser su : sessions) {
            if (!su.getAppointments().isEmpty()) {
                throw new BadRequestException("Không thể xin nghỉ nếu đã có lịch hẹn trong ngày này.");
            }
        }

        // Chỉ cập nhật các lịch tự tạo
        List<SessionUser> autoGeneratedSessions = sessions.stream()
                .filter(SessionUser::isAutoGenerated)
                .toList();

        if (autoGeneratedSessions.isEmpty()) {
            throw new BadRequestException("Không có lịch tự tạo nào để cập nhật.");
        }

        for (SessionUser session : autoGeneratedSessions) {
//            session.setAvailable(false);
//            session.setAutoGenerated(false);
            session.setLeaveStatus(LeaveStatus.PENDING);
        }
        sessionUserRepository.saveAll(autoGeneratedSessions);
    }
    @Transactional
    public void approveCoachLeave(ApproveLeaveDTO dto) {
        Account coach = authenticationRepository.findById(dto.getCoachId())
                .orElseThrow(() -> new BadRequestException("Không tìm thấy coach"));

        if (coach.getRole() != Role.COACH) {
            throw new BadRequestException("Tài khoản này không phải là coach.");
        }

        List<SessionUser> sessions = sessionUserRepository.findByAccountAndDate(coach, dto.getDate());

        List<SessionUser> pendingSessions = sessions.stream()
                .filter(s -> s.getLeaveStatus() == LeaveStatus.PENDING)
                .toList();

        if (pendingSessions.isEmpty()) {
            throw new BadRequestException("Không có yêu cầu nghỉ nào đang chờ duyệt.");
        }

        for (SessionUser s : pendingSessions) {
            s.setAvailable(false);
            s.setAutoGenerated(false);
            s.setLeaveStatus(LeaveStatus.COMPLETED);
        }

        sessionUserRepository.saveAll(pendingSessions);
    }

    public List<CoachLeaveRequestDTO> getPendingLeaveRequests() {
        List<SessionUser> sessions = sessionUserRepository.findByLeaveStatus(LeaveStatus.PENDING);

        // Nhóm theo coachId + date
        Map<String, CoachLeaveRequestDTO> uniqueRequests = new HashMap<>();

        for (SessionUser s : sessions) {
            Long coachId = s.getAccount().getId();
            LocalDate date = s.getDate();
            String key = coachId + "_" + date.toString();

            // Chỉ thêm nếu chưa tồn tại key
            uniqueRequests.putIfAbsent(key, new CoachLeaveRequestDTO(coachId, date));
        }

        return new ArrayList<>(uniqueRequests.values());
    }


    @Transactional
    public void cancelCoachLeave(ApproveLeaveDTO dto) {
        Account coach = authenticationRepository.findById(dto.getCoachId())
                .orElseThrow(() -> new BadRequestException("Không tìm thấy coach"));

        if (coach.getRole() != Role.COACH) {
            throw new BadRequestException("Tài khoản này không phải là coach.");
        }

        List<SessionUser> sessions = sessionUserRepository.findByAccountAndDate(coach, dto.getDate());

        List<SessionUser> pendingSessions = sessions.stream()
                .filter(s -> s.getLeaveStatus() == LeaveStatus.PENDING)
                .toList();

        if (pendingSessions.isEmpty()) {
            throw new BadRequestException("Không có yêu cầu nghỉ nào đang chờ duyệt.");
        }

        for (SessionUser s : pendingSessions) {
            s.setLeaveStatus(LeaveStatus.CANCELLED);
            // Giữ nguyên trạng thái available & autoGenerated
        }

        sessionUserRepository.saveAll(pendingSessions);
    }



    public void ensureSessionForCoachOnDate(Account coach, LocalDate date) {
        List<SessionUser> sessions = sessionUserRepository.findByAccountIdAndDate(coach.getId(), date);
        if (!sessions.isEmpty()) {
            System.out.println(" Coach ID " + coach.getId() + " đã có session ngày " + date);
            return;
        }

        List<Session> templates = sessionRepository.findAll();
        List<SessionUser> newSessions = new ArrayList<>();

        for (Session template : templates) {
            SessionUser su = new SessionUser();
            su.setAccount(coach);
            su.setDate(date);
            su.setStart(template.getStart());
            su.setEnd(template.getEnd());
            su.setLabel(template.getLabel());
            su.setAutoGenerated(true);
            newSessions.add(su);
        }

        sessionUserRepository.saveAll(newSessions);
        System.out.println("Tạo session cho Coach " + coach.getId() + " ngày " + date);
    }


    //// Chạy mỗi phút để test (không dùng trong production)
    @Scheduled(cron = "0 * * * * *")
   //@Scheduled(cron = "0 0 0 1 * *") // chạy 00:00 ngày đầu tiên mỗi tháng
    public void autoGenerateCoachSessions() {
        LocalDate startDate = LocalDate.now().withDayOfMonth(1); // ngày đầu tháng
        LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth()); // ngày cuối tháng

        List<Account> coaches = authenticationRepository.findByRole(Role.COACH);

        for (Account coach : coaches) {
            for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
                ensureSessionForCoachOnDate(coach, date);
            }
        }

        System.out.println(" Tự động tạo lịch làm cho coach trong tháng: " + startDate.getMonth());
    }

    public List<SessionUserDTO> getWorkingSessionsForCurrentCoach(LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new BadRequestException("Ngày bắt đầu phải trước hoặc bằng ngày kết thúc.");
        }

        Account coach = authenticationService.getCurentAccount();

        if (coach == null || coach.getRole() != Role.COACH) {
            throw new BadRequestException("Chỉ COACH mới có thể xem lịch làm việc của mình.");
        }

        List<SessionUser> sessions = sessionUserRepository
                .findByAccountAndDateBetweenOrderByDateAscStartAsc(coach, from, to);

        // Map sang DTO
        return sessions.stream().map(session -> {
            SessionUserDTO dto = new SessionUserDTO();
            dto.setDate(session.getDate());
            dto.setStart(session.getStart());
            dto.setEnd(session.getEnd());
            dto.setLabel(session.getLabel());
            dto.setAvailable(session.isAvailable());
            dto.setAutoGenerated(session.isAutoGenerated());
            dto.setLeaveStatus(session.getLeaveStatus());
            return dto;
        }).toList();
    }

    public List<SessionUserDTO> getAvailableSessionsForBooking(Long coachId, LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new BadRequestException("Ngày bắt đầu phải trước hoặc bằng ngày kết thúc.");
        }

        Account coach = authenticationRepository.findById(coachId)
                .orElseThrow(() -> new BadRequestException("Không tìm thấy coach."));

        Account customer = authenticationService.getCurentAccount();
        if (customer.getRole() != Role.CUSTOMER) {
            throw new BadRequestException("Chỉ có CUSTOMER mới được xem lịch.");
        }

        List<SessionUser> sessions = sessionUserRepository
                .findByAccountAndDateBetweenOrderByDateAscStartAsc(coach, from, to);

        return sessions.stream().map(session -> {
            SessionUserDTO dto = new SessionUserDTO();
            dto.setDate(session.getDate());
            dto.setStart(session.getStart());
            dto.setEnd(session.getEnd());
            dto.setLabel(session.getLabel());
            dto.setAvailable(session.isAvailable());
            dto.setAutoGenerated(session.isAutoGenerated());
            dto.setLeaveStatus(session.getLeaveStatus());
            return dto;
        }).toList();

    }

    public WorkDayStatsDTO getWorkDayStats(Long coachId, LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new BadRequestException("Ngày bắt đầu phải trước hoặc bằng ngày kết thúc.");
        }

        Account coach = authenticationRepository.findById(coachId)
                .orElseThrow(() -> new BadRequestException("Không tìm thấy coach."));

        List<SessionUser> sessions = sessionUserRepository
                .findByAccountAndDateBetweenOrderByDateAscStartAsc(coach, from, to);

        Map<LocalDate, List<SessionUser>> sessionsByDate = new HashMap<>();
        for (SessionUser su : sessions) {
            sessionsByDate.computeIfAbsent(su.getDate(), k -> new ArrayList<>()).add(su);
        }

        int dayOffs = 0;

        for (Map.Entry<LocalDate, List<SessionUser>> entry : sessionsByDate.entrySet()) {
            List<SessionUser> dailySessions = entry.getValue();

            boolean isDayOff = dailySessions.stream()
                    .allMatch(su ->
                            !su.isAvailable() &&
                                    !su.isAutoGenerated() &&
                                    su.getLeaveStatus() == LeaveStatus.COMPLETED
                    );


            if (isDayOff) {
                dayOffs++;
            }
        }

        int totalDaysWithSessions = sessionsByDate.keySet().size();
        int workingDays = totalDaysWithSessions - dayOffs;

        WorkDayStatsDTO dto = new WorkDayStatsDTO();
        dto.setTotalWorkingDays(workingDays);
        dto.setTotalDayOffs(dayOffs);
        return dto;
    }


}

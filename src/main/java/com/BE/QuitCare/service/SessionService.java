package com.BE.QuitCare.service;

import com.BE.QuitCare.dto.RegisterSessionDTO;
import com.BE.QuitCare.dto.RemoveSessionDTO;
import com.BE.QuitCare.dto.SessionUserDTO;
import com.BE.QuitCare.entity.Account;
import com.BE.QuitCare.entity.Appointment;
import com.BE.QuitCare.entity.Session;
import com.BE.QuitCare.entity.SessionUser;
import com.BE.QuitCare.enums.AppointmentEnum;
import com.BE.QuitCare.enums.Role;
import com.BE.QuitCare.exception.BadRequestException;
import com.BE.QuitCare.repository.AppointmentRepository;
import com.BE.QuitCare.repository.AuthenticationRepository;
import com.BE.QuitCare.repository.SessionRepository;
import com.BE.QuitCare.repository.SessionUserRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class SessionService
{

    @Autowired
    SessionRepository sessionRepository;
    @Autowired
    SessionUserRepository sessionUserRepository;
    @Autowired
    AuthenticationRepository authenticationRepository;
    @Autowired
    AuthenticationService  authenticationService;

    public List<Session> getTemplates() {
        return sessionRepository.findAll();
    }



    @PostConstruct
    public void initTemplates() {
        if (sessionRepository.count() == 0) {
            List<Session> templates = new ArrayList<>();
            LocalTime start = LocalTime.of(7, 0);
            LocalTime end = LocalTime.of(17, 0);

            while (start.plusMinutes(60).compareTo(end) <= 0) {
                Session template = new Session();
                template.setLabel(start.toString());
                template.setStart(start);
                template.setEnd(start.plusMinutes(60));
                templates.add(template);

                start = start.plusMinutes(60);
            }

            sessionRepository.saveAll(templates);
        }
    }

    @Transactional
    public void removeWorkingDay(RemoveSessionDTO dto) {
        Account account = authenticationRepository.findById(dto.getAccountId())
                .orElseThrow(() -> new BadRequestException("Không tìm thấy tài khoản"));

        if (account.getRole() != Role.COACH) {
            throw new BadRequestException("Chỉ Coach mới được hủy lịch làm.");
        }

        List<SessionUser> sessions = sessionUserRepository.findByAccountAndDate(account, dto.getDate());

        if (sessions.isEmpty()) {
            throw new BadRequestException("Không có lịch làm nào trong ngày này để hủy.");
        }

        // Kiểm tra nếu bất kỳ session nào có cuộc hẹn → từ chối hủy
        for (SessionUser su : sessions) {
            if (!su.getAppointments().isEmpty()) {
                throw new BadRequestException("Không thể xin nghỉ nếu đã có lịch hẹn trong ngày này.");
            }
        }

        // Lọc và xóa các session được tạo tự động
        List<SessionUser> autoGeneratedSessions = sessions.stream()
                .filter(SessionUser::isAutoGenerated)
                .toList();

        if (autoGeneratedSessions.isEmpty()) {
            throw new BadRequestException("Không có lịch tự tạo nào để xóa.");
        }

        sessionUserRepository.deleteAll(autoGeneratedSessions);
    }


    public void ensureSessionForCoachOnDate(Account coach, LocalDate date) {
        List<SessionUser> sessions = sessionUserRepository.findByAccountAndDate(coach, date);
        if (!sessions.isEmpty()) return;

        List<Session> templates = sessionRepository.findAll();
        List<SessionUser> newSessions = new ArrayList<>();

        for (Session template : templates) {
            SessionUser su = new SessionUser();
            su.setAccount(coach);
            su.setDate(date);
            su.setStart(template.getStart());
            su.setEnd(template.getEnd());
            su.setLabel(template.getLabel());
            su.setAutoGenerated(true);
            newSessions.add(su);
        }

        sessionUserRepository.saveAll(newSessions);
    }
    //// Chạy mỗi phút để test (không dùng trong production)
    @Scheduled(cron = "0 * * * * *")
    //@Scheduled(cron = "0 0 0 1 * *") // chạy 00:00 ngày đầu tiên mỗi tháng
    public void autoGenerateCoachSessions() {
        LocalDate startDate = LocalDate.now().withDayOfMonth(1); // ngày đầu tháng
        LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth()); // ngày cuối tháng

        List<Account> coaches = authenticationRepository.findByRole(Role.COACH);

        for (Account coach : coaches) {
            for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
                ensureSessionForCoachOnDate(coach, date);
            }
        }

        System.out.println(" Tự động tạo lịch làm cho coach trong tháng: " + startDate.getMonth());
    }

    public List<SessionUserDTO> getWorkingSessionsForCurrentCoach(LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new BadRequestException("Ngày bắt đầu phải trước hoặc bằng ngày kết thúc.");
        }

        Account coach = authenticationService.getCurentAccount();

        if (coach == null || coach.getRole() != Role.COACH) {
            throw new BadRequestException("Chỉ COACH mới có thể xem lịch làm việc của mình.");
        }

        List<SessionUser> sessions = sessionUserRepository
                .findByAccountAndDateBetweenOrderByDateAscStartAsc(coach, from, to);

        // Map sang DTO
        return sessions.stream().map(session -> {
            SessionUserDTO dto = new SessionUserDTO();
            dto.setDate(session.getDate());
            dto.setStart(session.getStart());
            dto.setEnd(session.getEnd());
            dto.setLabel(session.getLabel());
            dto.setAvailable(session.isAvailable());
            dto.setAutoGenerated(session.isAutoGenerated());
            return dto;
        }).toList();
    }

    public List<SessionUserDTO> getAvailableSessionsForBooking(Long coachId, LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new BadRequestException("Ngày bắt đầu phải trước hoặc bằng ngày kết thúc.");
        }

        Account coach = authenticationRepository.findById(coachId)
                .orElseThrow(() -> new BadRequestException("Không tìm thấy coach."));

        Account customer = authenticationService.getCurentAccount();
        if (customer.getRole() != Role.CUSTOMER) {
            throw new BadRequestException("Chỉ có CUSTOMER mới được xem lịch.");
        }

        List<SessionUser> sessions = sessionUserRepository
                .findByAccountAndDateBetweenAndIsAvailableTrueOrderByDateAscStartAsc(coach, from, to);

        return sessions.stream().map(session -> {
            SessionUserDTO dto = new SessionUserDTO();
            dto.setDate(session.getDate());
            dto.setStart(session.getStart());
            dto.setEnd(session.getEnd());
            dto.setLabel(session.getLabel());
            dto.setAvailable(session.isAvailable());
            dto.setAutoGenerated(session.isAutoGenerated());
            return dto;
        }).toList();

    }






}
